<?xml version="1.0" encoding="UTF-8"?>
<mule xmlns:dw="http://www.mulesoft.org/schema/mule/ee/dw"
	xmlns:batch="http://www.mulesoft.org/schema/mule/batch" xmlns:netsuite="http://www.mulesoft.org/schema/mule/netsuite"
	version="EE-3.7.2" xmlns="http://www.mulesoft.org/schema/mule/core"
	xmlns:doc="http://www.mulesoft.org/schema/mule/documentation"
	xmlns:sfdc="http://www.mulesoft.org/schema/mule/sfdc" xmlns:spring="http://www.springframework.org/schema/beans"
	xmlns:tracking="http://www.mulesoft.org/schema/mule/ee/tracking"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-current.xsd
http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
http://www.mulesoft.org/schema/mule/ee/tracking http://www.mulesoft.org/schema/mule/ee/tracking/current/mule-tracking-ee.xsd
http://www.mulesoft.org/schema/mule/sfdc http://www.mulesoft.org/schema/mule/sfdc/current/mule-sfdc.xsd
http://www.mulesoft.org/schema/mule/netsuite http://www.mulesoft.org/schema/mule/netsuite/current/mule-netsuite.xsd
http://www.mulesoft.org/schema/mule/batch http://www.mulesoft.org/schema/mule/batch/current/mule-batch.xsd
http://www.mulesoft.org/schema/mule/ee/dw http://www.mulesoft.org/schema/mule/ee/dw/current/dw.xsd">
    <batch:job name="syncOpportunitiesBatch" max-failed-records="-1">
        <batch:process-records>
            <batch:step name="findCustomer">
                <logger message="Input Opportunity: #[payload]" level="INFO" doc:name="Logger"/>
                <enricher source="#[payload.hasNext() ? payload.next() : null]" target="#[recordVars['custInNetsuiteExtId']]" doc:name="store in custInNetsuiteExtId">
                    <processor-chain doc:name="Processor Chain">
                        <netsuite:query-records config-ref="Netsuite" query="dsql:SELECT externalId FROM CUSTOMER WHERE externalId = '#[payload.Account.Id]'" doc:name="get Customer in NetSuite External ID"/>
                    </processor-chain>
                </enricher>
                <logger message="Customer: #[recordVars.custInNetsuite]" level="INFO" doc:name="Logger"/>
            </batch:step>
            <batch:step name="prepareCustomerId">
                <choice doc:name="doesCustomerExist">
                    <when expression="#[recordVars['custInNetsuiteExtId'] == null]">
                        <enricher source="#[payload.getExternalId()]" target="#[recordVars['idOfCustomerInNetsuite']]" doc:name="store result in idOfCustomerInNetsuite">
                            <processor-chain doc:name="Processor Chain">
                                <dw:transform-message doc:name="Account to Customer">
                                    <dw:set-payload><![CDATA[%dw 1.0
%output application/java
---
{
	companyName: payload.Account.Name,
	externalId: payload.Account.Id,
	fax: payload.Account.Fax,
	phone: payload.Account.Phone,
	subsidiary: {
		internalId: p('nets.subsidiaryId')
	}
}]]></dw:set-payload>
                                </dw:transform-message>
                                <netsuite:add-record config-ref="Netsuite" recordType="CUSTOMER" doc:name="add Customer">
                                    <netsuite:attributes ref="#[payload]"/>
                                </netsuite:add-record>
                            </processor-chain>
                        </enricher>
                    </when>
                    <otherwise>
                        <batch:set-record-variable variableName="idOfCustomerInNetsuite" value="#[recordVars.custInNetsuiteExtId.externalId]" doc:name="set idOfCustomerInNetsuite to existing value"/>
                    </otherwise>
                </choice>
                <logger message="Customer ID: #[recordVars.idOfCustomerInNetsuite]" level="INFO" doc:name="Logger"/>
            </batch:step>
            <batch:step name="upsertInventoryItems">
                <enricher source="#[payload]" target="#[recordVars['itemsUpsertResult']]" doc:name="upsert invertoryItems">
                    <processor-chain doc:name="Processor Chain">
                        <dw:transform-message doc:name="OpportunityLineItems To InventoryItems">
                            <dw:set-payload><![CDATA[%dw 1.0
%output application/java
%function convertToArray(records) {
	recordList : records when (records is :array) otherwise [records]
}
---
convertToArray(payload.OpportunityLineItems.records).recordList map
{
	cost: $.ListPrice,
	displayName: $.Name,
	externalId: $.Product2Id,
	itemId: $.ProductCode,
	quantityAvailable: $.Quantity,
	subsidiaryList: {
		recordRef: [{
			internalId: p('nets.subsidiaryId')
		}]
	}
}]]></dw:set-payload>
                        </dw:transform-message>
                        <netsuite:upsert-list config-ref="Netsuite" recordType="INVENTORY_ITEM" doc:name="upsert inventoryItems">
                            <netsuite:records ref="#[payload]"/>
                        </netsuite:upsert-list>
                    </processor-chain>
                </enricher>
            </batch:step>
            <batch:step name="createSalesOrderInNetsuite" accept-expression="!(payload is NullPayload)">
                <dw:transform-message doc:name="prepare data to insert Sales Order">
                    <dw:set-payload><![CDATA[%dw 1.0
%output application/java
%function convertToArray(records) {
	recordList : records when (records is :array) otherwise [records]
}
---
{
	entity: {
		externalId: recordVars.idOfCustomerInNetsuite
	},
	externalId: payload.Id,
	itemList: {
		item: convertToArray(payload.OpportunityLineItems.records).recordList map {
			amount: $.ListPrice,
			item: {
				externalId: $.Product2Id
			},
			quantity: $.Quantity
		},
		replaceAll: true
	},
	orderStatus: "PENDING_FULFILLMENT"
}]]></dw:set-payload>
                </dw:transform-message>
                <netsuite:upsert-record config-ref="Netsuite" recordType="SALES_ORDER" doc:name="upsert Sales Order in Netsuite">
                    <netsuite:attributes ref="#[payload]"/>
                </netsuite:upsert-record>
                <logger message="Upserted sales order with internal ID: #[payload.getInternalId()] " level="INFO" doc:name="log Upsert result"/>
            </batch:step>
        </batch:process-records>
    </batch:job>
    <flow doc:description="This flow is the entry point to the Kick business logic.  This flow should control the direction of the application, and it should be called by the different endpoints that your Kick exposes to trigger it." name="mainFlow" processingStrategy="synchronous">
        <batch:execute name="syncOpportunitiesBatch" doc:name="syncOpportunitiesBatch"/>

        <exception-strategy doc:name="Reference Exception Strategy" ref="defaultChoiceExceptionStrategy"/>
    </flow>


</mule>